#include "aes_misc.h"

int encrypt_file(uint8_t* key, int key_size, int encryption_mode, FILE* file) {

  switch (encryption_mode) {
    case 0 /*ECB*/:
      printf("Not implemented yet\n");
      break;
    case 1 /*OFB*/:
      ofb_encrypt(key, key_size, file);
      break;
    default:
      printf("Please specify an encryption mode\n");
      break;
  }

  return EXIT_SUCCESS;
}

int decrypt_file(uint8_t* key, int key_size, int encryption_mode, FILE* file) {

  switch (encryption_mode) {
    case 0 /*ECB*/:
      printf("Not implemented yet\n");
      break;
    case 1 /*OFB*/:
      ofb_decrypt(key, key_size, file);
      break;
    default:
      printf("Please specify a decryption mode\n");
      break;
  }

  return EXIT_SUCCESS;
}

int ofb_round(uint8_t* key, int key_size, uint8_t* iv, uint8_t* data_block) {
  int i;
  cipher_block(iv, key, key_size);
  for (i=0; i<16; i++) data_block[i] ^= iv[i];
}

int ofb_encrypt(uint8_t* key, int key_size, FILE* data_file) {

  int rcc, p;
  uint8_t *data_block, *iv;
  FILE* tmp_ciphile;

  tmp_ciphile = fopen("tmp_ciphile", "wb+");

  iv = malloc(16*sizeof(uint8_t));
  data_block = malloc(16*sizeof(uint8_t));

  getrandom(iv, 16, 0);

  strcpy(iv, "0123456789ABCDE");

  while ( (rcc = fread(data_block, (size_t)1, (size_t)16, data_file)) == 16) {
    ofb_round(key, key_size, iv, data_block);
    fwrite(data_block, (size_t)1, (size_t)16, tmp_ciphile);
  }

  // PKCS#7 compliant padding
  if (rcc != 0) {
    p = 16-rcc;
    memset(data_block+rcc, p, p);
    ofb_round(key, key_size, iv, data_block);
    fwrite(data_block, (size_t)1, (size_t)16, tmp_ciphile);
  }
  else {
    memset(data_block, 16, 16);
    ofb_round(key, key_size, iv, data_block);
    fwrite(data_block, (size_t)1, (size_t)16, tmp_ciphile);
  }

  fclose(tmp_ciphile);

  return EXIT_SUCCESS;
}

int ofb_decrypt(uint8_t* key, int key_size, FILE* ciph_file) {

  int rcc, p;
  uint8_t *data_block, *iv;
  FILE* tmp_clearfile;
  fpos_t* position;

  tmp_clearfile = fopen("tmp_clearfile", "wb+");

  iv = malloc(16*sizeof(uint8_t));
  data_block = malloc(16*sizeof(uint8_t));
  position = malloc(sizeof(fpos_t));

  getrandom(iv, 16, 0);

  strcpy(iv, "0123456789ABCDE");

  while ( (rcc = fread(data_block, (size_t)1, (size_t)16, ciph_file)) == 16) {
    ofb_round(key, key_size, iv, data_block);

    fgetpos(ciph_file, position);
    getc(ciph_file);
    if (feof(ciph_file)) {
      printf("Detected EOF\n");
      break;
    }
    fsetpos(ciph_file, position);

    fwrite(data_block, (size_t)1, (size_t)16, tmp_clearfile);
  }

  // Write the block minus the padding
  p = 16 - data_block[15];
  fwrite(data_block, (size_t)1, (size_t)p, tmp_clearfile);

  fclose(tmp_clearfile);

  return EXIT_SUCCESS;
}
